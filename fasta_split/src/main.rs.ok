extern crate bio;
use std::io::BufReader;
use std::io::BufRead;
use std::fs::File;


use std::str;
use std::io;
use std::io::BufWriter;
use std::path::Path;
use clap::Parser;
use std::io::Write;
use std::cmp::Reverse;
use std::collections::HashMap;
use bio::io::fasta;
use bio::io::fasta::Writer;
use bio::io::gff;
use bio::alphabets::dna;
use bio_types::strand;



// Arguments et Options
#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    /// FASTA (file path or stdin)
    fasta_path : std::path::PathBuf,    // Fichier fasta
	fam_file : String,    				// Fichier famille
	#[arg(long,default_value_t = false)]
    orphans : bool,                     // Traite les orphans,

}

// Sequence Fasta
type FastaSeqs = Vec<FastaSeq>;
#[derive(Debug)]
struct FastaSeq {
    id:String,      // nom de la sequence
    seq:Vec<u8>,    // sequence
}

/// Famille
struct Famille {
	id:String,
	seqs:Vec<String>
}
type Familles = Vec<Famille>;

fn read_families(filename :String) -> HashMap::<String,Vec<String>>{
 	let file = File::open(filename);
    let file = match file {
    	Ok(file) => file,
    	Err(e) => {
			panic!("Impossible d'ouvrir le fichier de famille")
    	},
    };
	let reader = BufReader::new(file);
	let mut dico =  HashMap::<String,Vec<String>>::new();
    for line in reader.lines() {
        let line = line.expect("Probleme de lecture");
  
        let split_line: Vec<&str> = line.split('\t').collect();
        println!("{:?}",split_line);
        let fam = split_line[0].to_string();
        let seq = split_line[1].to_string();
        
        if !dico.contains_key(&fam) {
                dico.insert(fam.clone(),vec![]);
            };
        if let Some(x) = dico.get_mut(&fam) {
                x.push(seq);
            };

	}
	dico
}
//  Lecture des sequences FASTA
fn traverse_fasta_file(path : &str) -> FastaSeqs {
    println!("FILE = {}",path);
    if path == "stdin" { println!("FASTA form stdin ")};
    match path {
        "stdin" => {
            let reader = fasta::Reader::new(io::stdin());
            processing_fasta(reader)
        },
        _ => {
            let reader = fasta::Reader::from_file(path).unwrap();
            processing_fasta(reader)
        },
    }
}
fn processing_fasta<B>(reader: fasta::Reader<B>) -> FastaSeqs where B: BufRead{
    let mut fastaseqs = Vec::new();
    for result in reader.records() {
        let record = result.expect("Error during fasta record parsing");
        let id = record.id();
        let seq = record.seq();
        //println!("{:?}",id);
        fastaseqs.push(
            FastaSeq{
                id: id.to_string(),
                seq: seq.to_vec(),
            });
    }
    fastaseqs
}
fn main() {
    let args = Cli::parse();
    println!("Hello, world!");
        println!("Lecture Fasta....");
    let fastas = traverse_fasta_file(args.fasta_path.to_str().expect("Pas de fichier fasta"));
   //for fasta in &fastas {
   //     println!("{} -> {}",fasta.id,fasta.seq.len());
   // }
    println!("ok");
    let fam_dico = read_families(args.fam_file);
    let nb_seq_fasta = fastas.len();
    let mut dico_sequence_index =  HashMap::<String,usize>::new();
    for i in 0 .. nb_seq_fasta {
        if !dico_sequence_index.contains_key(&fastas[i].id) {
            dico_sequence_index.insert(fastas[i].id.clone(),i);
        }
        else {
            panic!("La sequence {} est definie plusieurs fois",fastas[i].id);
        }
    }

	 for (key, value) in fam_dico {
	 	println!("Famille {}",key);
	 	if (value.len() > 1) || args.orphans { 
	 	for seq in value {
	 		println!(">>>> {}",seq);
	 		let idx = *dico_sequence_index.get(&seq).expect("Sequence introuvable");
	 		println!("trouve {:?}",fastas[idx]);
	 	}}
	 	
	 }
}
